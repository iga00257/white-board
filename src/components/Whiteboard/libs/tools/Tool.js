/**
 * gen uuid on client-side
 */
/**
 * hash: shape-hash used for message & redo/undo
 * JSON: JSON generated by paper.js
 * instance: item create by tools
 * path: item create by paper.js
 */
import paper from 'paper';
import commands from '../commands';
import { isValidMouseup } from '../utils';

let generateId = function(salt = 0) {
  let ts = new Date().getTime() % 10000000;
  let r = parseInt((Math.random() * 100) % 100, 10);
  //return (ts + r + salt).toString(36);
  return ts * 1000 + r * 10 + salt;
};

export const formatToNumber = str => {
  if (!str) return 0;
  return Number(str.toFixed(0));
};

export class PaperItem {
  constructor(tool, path, id) {
    path.data.managed = true; // marked as managed by whiteboard;
    path.instance = this;

    this.tool = tool;
    this.id = id || generateId();
    this.path = path;

    let self = this;

    //aliaes of methods
    ['move', 'scale', 'select', 'remove', 'mutateHash'].forEach(method => {
      this[method] = function() {
        tool[method](self, ...arguments);
        path[`on${method}`] && path[`on${method}`](...arguments);
      };
    });
  }

  get hash() {
    return this.tool.getHash(this.path, this.id);
  }

  get json() {
    return this.tool.getJSON(this.path, this.id);
  }
}

/**
 * Tool base class.
 */
export class Tool {
  constructor(type, overwrite) {
    this.type = type;
    this.eventItem = null; //item cached on mouse-event
    this.zoom = 1;
    this.style = {
      // strokeColor: 'red',
      // strokeWidth: 5,
      //strokeCap: 'round',
      //strokeJoin: 'round',
    };

    if (overwrite) {
      for (let key in overwrite) {
        this[key] = overwrite[key];
      }
    }
  }

  mutateHash() {}
  setSelected(val) {} //set selected state of tool

  setStyle(style = {}) {
    //set style of tool
    Object.assign(this.style, style);
  }

  remove(hash) {
    hash.path.remove();
  }

  createInstance(path, id) {
    return new PaperItem(this, path, id);
  }

  /**
   * get item shape json via paper.js API
   * @param {*} id
   * @param {*} path
   */
  getJSON(path, id) {
    return [
      this.type,
      id,
      path.exportJSON({
        asString: false,
        precision: 0,
      }),
    ];
  }

  /**
   * this methods generate shape json for socket-message & redo, undo actions. It short
   * @param {*} item
   */
  getHash(path, id) {
    return [
      this.type,
      id,
      path.data.json,
      {
        c: this.style.strokeColor, //strokecolor
        w: this.style.strokeWidth, //strokewidth
        f: this.style.fontSize, //fontSize
        fc: this.style.fillColor, //fillColor
      },
    ];
  }
}

/**
 * Shape tool base class
 */
class Shape extends Tool {
  drawViaJSON(json) {
    let path = new paper.Path();
    path.importJSON(json[2]);

    return this.createInstance(path, json[1]);
  }

  draw(hash) {
    const [startPoint, endPoint] = hash[2];

    let path = this.render(new paper.Point(startPoint), new paper.Point(endPoint));

    this.applyStyle(path, hash[3]);
    /**
     * custom data json store startpoint & end point of this shape
     */
    path.data.json = [startPoint, endPoint];
    return this.createInstance(path, hash[1], hash[3]);
  }

  renderPath(startPoint, endPoint) {
    throw new Error('Render methods must be overwirte by shape-tool self!');
  }

  render(startPoint, endPoint) {
    return this.applyStyle(this.renderPath(startPoint, endPoint));
  }

  applyStyle(path, style) {
    style = Object.assign(
      {},
      this.style,
      style
        ? {
            strokeColor: style.c,
            strokeWidth: style.w,
            fillColor: style.fc, //fillColor
          }
        : {}
    );

    path && (path.style = style);
    return path;
  }

  scale(instance, scale) {
    instance.path.scale(scale.sx, scale.sy, scale.basePoint);
  }

  move(instance, offset) {
    let x = instance.path.position.x + offset.x;
    let y = instance.path.position.y + offset.y;

    instance.path.setPosition(x, y);
  }

  mutateHash(item, mode, params) {
    if (mode === 'MOVE') {
      if (!item.path.data.json) return;
      let [[sx, sy], [ex, ey]] = item.path.data.json;
      item.path.data.json = [[sx + params.x, sy + params.y], [ex + params.x, ey + params.y]];
    }
    // else if (mode === 'SCALE') {
    // }
  }

  mouseDragHandler(event) {
    this.eventItem && this.eventItem.remove();
    this.eventItem = this.render(event.downPoint, event.point);
  }

  mouseUpHandler(event) {
    if (!this.eventItem) return;

    if (!isValidMouseup(event.downPoint, event.point)) {
      this.eventItem.remove();
      return (this.eventItem = null);
    }

    // animation
    // this.eventItem.onFrame =  function(event) {
    //     // Every frame, rotate the path by 3 degrees:
    // }

    this.eventItem.data.json = [
      [formatToNumber(event.downPoint.x), formatToNumber(event.downPoint.y)],
      [formatToNumber(event.point.x), formatToNumber(event.point.y)],
    ];
    commands.send('ADD', [this.createInstance(this.eventItem)]);
    this.eventItem = null;
  }
}

class FreeHand extends Shape {
  draw(hash) {
    const paths = hash[2].map(point => {
      const [basePoint, handleIn, handleOut] = point;
      return new paper.Segment(basePoint, handleIn, handleOut);
    });

    const item = new paper.Path(paths);
    this.applyStyle(item, hash[3]);

    return this.createInstance(item, hash[1]);
  }

  mouseMoveHandler(event) {
    if (this.onMove) {
      this.onMove(event.point);
    }
  }

  mouseDragHandler(event) {
    if (this.onMove) {
      this.onMove(event.point);
    }
    if (!this.eventItem) {
      this.eventItem = new paper.Path(event.point);
    } else {
      this.eventItem.add(event.point);
    }
    this.applyStyle(this.eventItem);
  }

  mouseUpHandler(event) {
    if (!this.eventItem) return;
    if (this.eventItem.segments.length === 1) {
      //invalid path;
      this.eventItem.remove();
      return (this.eventItem = null);
    }
    this.eventItem.simplify();
    commands.send('ADD', [this.createInstance(this.eventItem)]);
    this.eventItem = null;
  }

  getHash(path, id) {
    let json = path.exportJSON({ asString: false, precision: 0 });

    let simplifiedSegs = json[1].segments;

    return [
      this.type,
      id,
      simplifiedSegs,
      {
        c: this.style.strokeColor, //strokecolor
        w: this.style.strokeWidth, //strokewidth
        fc: this.style.fillColor, //fillColor
      },
    ];
  }
}

/**
 * Factory method to create tool.
 * @param {string} name
 * @param {object} options
 */
export const createTool = function(name, options) {
  return new Tool(name, options);
};

/**
 * Factory method to create shape tool.
 * @param {string} name
 * @param {object} options
 */
export const createShapeTool = function(name, options) {
  return new Shape(name, options);
};

/**
 * Factory method to create shape tool.
 * @param {string} name
 * @param {object} options
 */
export const createFreeHandTool = function(name, options) {
  return new FreeHand(name, options);
};
